import json
import os
import networkx as nx
from networkx.drawing.nx_agraph import to_agraph

def draw_network_graph(json_file_path, output_image_path):
    """
    Loads a graph from a JSON file and draws it using networkx and pygraphviz.

    Args:
        json_file_path (str): The path to the aggregated JSON graph file.
        output_image_path (str): The path to save the output image (e.g., 'graph.svg').
    """
    # --- 1. Load the JSON data ---
    try:
        with open(json_file_path, 'r', encoding='utf-8') as f:
            data = json.load(f)
    except FileNotFoundError:
        print(f"Error: The file '{json_file_path}' was not found.")
        print("Please ensure it's in the same directory as the script and has been generated by the aggregation script.")
        return
    except json.JSONDecodeError:
        print(f"Error: Could not decode JSON from '{json_file_path}'. The file might be corrupted.")
        return

    # --- 2. Create a NetworkX Graph ---
    # We use a simple Graph object for visualization purposes.
    G = nx.Graph()

    # Add nodes to the graph, storing their label and type as attributes.
    for node in data['nodes']:
        # Prioritize 'short_name', then 'label', then 'id' for the display label
        label = node.get('short_name', node.get('label', node['id']))
        G.add_node(node['id'], label=label, type=node.get('type', 'internal'))

    # Add edges to the graph, storing the edge_type as an attribute.
    for edge in data['edges']:
        if G.has_node(edge['from']) and G.has_node(edge['to']):
            G.add_edge(edge['from'], edge['to'], edge_type=edge.get('edge_type', 'internal'))

    # --- 3. Convert to PyGraphviz for layout and rendering ---
    # This gives us access to the powerful Graphviz layout algorithms.
    A = to_agraph(G)
    A.graph_attr.update(splines=True, overlap='prism', bgcolor='transparent', pad=0.1)
    A.node_attr.update(style='filled', shape='ellipse', fontname='Helvetica', fontsize=10)
    A.edge_attr.update(fontname='Helvetica', fontsize=8)

    # --- 4. Customize Nodes and Edges based on their attributes ---
    for node_id in A.nodes():
        node = A.get_node(node_id)
        node_attrs = G.nodes[node_id]

        # Set node colors based on 'type'
        if node_attrs.get('type') == 'external':
            node.attr['fillcolor'] = '#A2D9CE'  # Light teal
            node.attr['fontcolor'] = '#145A32'
        else: # Internal nodes
            node.attr['fillcolor'] = '#AED6F1'  # Light blue

        # Set the node's display label
        node.attr['label'] = node_attrs.get('label', node_id)

    for edge in A.edges():
        # Retrieve edge data from the NetworkX graph
        node1, node2 = edge
        if G.has_edge(node1, node2):
            edge_attrs = G.get_edge_data(node1, node2)

            # Set edge colors and styles based on 'edge_type'
            if edge_attrs.get('edge_type') == 'external':
                edge.attr['color'] = '#E74C3C'  # Red
                edge.attr['style'] = 'dashed'
            else: # Internal edges
                edge.attr['color'] = '#707B7C'  # Gray

    # --- 5. Render the graph to a file ---
    # 'neato' is a spring-model layout engine good for this type of network.
    # Other options: 'dot' (hierarchical), 'fdp' (force-directed), 'circo' (circular)
    A.layout('neato')
    
    try:
        A.draw(output_image_path)
        print(f"Graph has been drawn successfully and saved to '{output_image_path}'")
    except Exception as e:
        print(f"An error occurred while drawing the graph: {e}")
        print("\nPlease ensure the Graphviz software is correctly installed and accessible in your system's PATH.")

if __name__ == '__main__':
    # Define the input and output filenames
    JSON_FILE = 'aggregated_graph_deduplicated.json'
    OUTPUT_IMAGE = 'network_graph.svg'  # SVG is a vector format, great for zooming
    
    # Run the drawing function
    draw_network_graph(JSON_FILE, OUTPUT_IMAGE)