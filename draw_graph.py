import json
import os
import networkx as nx
from networkx.drawing.nx_agraph import to_agraph

def draw_network_graph(json_file_path, output_image_path):
    """
    Loads a graph from a JSON file and draws it using networkx and pygraphviz.
    External edges are styled differently based on their 'link_type' (transit or peering).

    Args:
        json_file_path (str): The path to the aggregated JSON graph file.
        output_image_path (str): The path to save the output image (e.g., 'graph.svg').
    """
    # --- 1. Load the JSON data ---
    try:
        with open(json_file_path, 'r', encoding='utf-8') as f:
            data = json.load(f)
    except FileNotFoundError:
        print(f"Error: The file '{json_file_path}' was not found.")
        print("Please ensure it's in the same directory as the script and has been generated by the previous step.")
        return
    except json.JSONDecodeError:
        print(f"Error: Could not decode JSON from '{json_file_path}'. The file might be corrupted.")
        return

    # --- 2. Create a NetworkX Graph ---
    G = nx.Graph()

    # Add nodes to the graph with their attributes.
    for node in data['nodes']:
        label = node.get('short_name', node.get('label', node['id']))
        G.add_node(
            node['id'],
            label=label,
            type=node.get('type', 'internal')
        )

    # Add edges to the graph, storing both edge_type and link_type.
    for edge in data['edges']:
        if G.has_node(edge['from']) and G.has_node(edge['to']):
            G.add_edge(
                edge['from'],
                edge['to'],
                edge_type=edge.get('edge_type', 'internal'),
                link_type=edge.get('link_type')  # This will be None for internal links
            )

    # --- 3. Convert to PyGraphviz for layout and rendering ---
    A = to_agraph(G)
    A.graph_attr.update(splines=True, overlap='prism', bgcolor='transparent', pad=0.1, K=0.8)
    A.node_attr.update(style='filled', shape='ellipse', fontname='Helvetica', fontsize=10)
    A.edge_attr.update(fontname='Helvetica', fontsize=8)

    # --- 4. Customize Nodes and Edges based on their attributes ---
    for node_id in A.nodes():
        node = A.get_node(node_id)
        node_attrs = G.nodes[node_id]

        # Set node colors based on 'type'
        if node_attrs.get('type') == 'external':
            node.attr['fillcolor'] = '#A2D9CE'  # Light teal
            node.attr['fontcolor'] = '#145A32'
        else:  # Internal nodes
            node.attr['fillcolor'] = '#AED6F1'  # Light blue

        # Set the node's display label
        node.attr['label'] = node_attrs.get('label', node_id)

    # --- MODIFICATION START ---
    # Customize edges based on their type (internal vs. external) and link_type (transit vs. peering)
    for edge in A.edges():
        node1, node2 = edge
        if G.has_edge(node1, node2):
            edge_attrs = G.get_edge_data(node1, node2)
            edge_type = edge_attrs.get('edge_type')

            if edge_type == 'external':
                link_type = edge_attrs.get('link_type')

                if link_type == 'transit':
                    # Style for Transit links: Solid, thicker, and red
                    edge.attr['color'] = '#E74C3C'    # Red
                    edge.attr['style'] = 'solid'
                    edge.attr['penwidth'] = 1.5
                elif link_type == 'peering':
                    # Style for Peering links: Dashed and blue
                    edge.attr['color'] = '#2980B9'    # Blue
                    edge.attr['style'] = 'dashed'
                else:
                    # Fallback style for any other external links
                    edge.attr['color'] = '#F39C12'    # Orange
                    edge.attr['style'] = 'dotted'
            else:
                # Style for Internal links: Gray and solid
                edge.attr['color'] = '#707B7C'        # Gray
                edge.attr['style'] = 'solid'
    # --- MODIFICATION END ---

    # --- 5. Render the graph to a file ---
    # 'neato' is a spring-model layout engine good for this type of network.
    A.layout('neato')

    try:
        A.draw(output_image_path)
        print(f"Graph has been drawn successfully and saved to '{output_image_path}'")
    except Exception as e:
        print(f"An error occurred while drawing the graph: {e}")
        print("\nPlease ensure the Graphviz software is correctly installed and accessible in your system's PATH.")

if __name__ == '__main__':
    # Define the input and output filenames
    JSON_FILE = 'final_graph_link_types.json'
    OUTPUT_IMAGE = 'network_graph_classified.svg'  # Use a new name for the output file
    
    # Run the drawing function
    draw_network_graph(JSON_FILE, OUTPUT_IMAGE)